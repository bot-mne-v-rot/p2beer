package ru.emkn.p2beer.p2p.network

import kotlinx.coroutines.*

import ru.emkn.p2beer.p2p.network.ProtocolRouterProtos.ProtocolMessage as ProtocolMessageProto
import ru.emkn.p2beer.p2p.network.ProtocolRouterProtos.ProtocolVersion as ProtocolVersionProto
import ru.emkn.p2beer.p2p.network.ProtocolRouterProtos.ProtocolDescriptor as ProtocolDescriptorProto
import com.google.protobuf.ByteString

internal class ProtocolRouterExtensionImpl : ProtocolRouterExtension() {
    override val protocols = mutableMapOf<ProtocolDescriptor, ExtensionNode>()

    override suspend fun extendStream(node: StreamListNode) = coroutineScope {
        val routerStream = ProtocolRouterStreamImpl(protocols.keys)
        node.child = routerStream
        routerStream.protocols.forEach { (descriptor, stream) ->
            launch { protocols[descriptor]?.extendStream(stream) }
        }
    }
}

internal class PerProtocolStream(private val descriptor: ProtocolDescriptor) : StreamListNode() {
    override suspend fun send(message: Buffer) {
        val proto = serializeMessage(ProtocolMessage(descriptor, message))
        parent?.send(proto.toByteArray())
    }
}

internal class ProtocolRouterStreamImpl(descriptors: Set<ProtocolDescriptor>) : ProtocolRouterStream() {
    internal val protocols = descriptors.associateWith {
        val stream = PerProtocolStream(it)
        stream.parent = this
        stream
    }

    override suspend fun receive(message: Buffer) : Unit = coroutineScope {
        val protobuf = async(Dispatchers.IO) {
            ProtocolMessageProto.parseFrom(message)
        }
        val (descriptor, inMsg) = deserializeMessage(protobuf.await())
        val ourDescriptor = protocols.keys.first {
            descriptor compatibleWith it
        }

        protocols[ourDescriptor]?.receive(inMsg)
    }

    override suspend fun performClosure() = coroutineScope {
        val async = protocols.values.map { launch { it.performClosure() } }
        joinAll(*async.toTypedArray())
        opened = false
    }

    override suspend fun performHandshake() = coroutineScope {
        for (node in protocols.values)
            launch { node.performHandshake() }
    }
}

internal data class ProtocolMessage(val descriptor: ProtocolDescriptor, val message: Buffer) {
    /**
     * Automatically generated by IDE
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ProtocolMessage

        if (descriptor != other.descriptor) return false
        if (!message.contentEquals(other.message)) return false

        return true
    }

    /**
     * Automatically generated by IDE
     */
    override fun hashCode(): Int {
        var result = descriptor.hashCode()
        result = 31 * result + message.contentHashCode()
        return result
    }
}

internal fun serializeVersion(version: ProtocolVersion) =
    ProtocolVersionProto.newBuilder()
        .setMajor(version.major.toInt())
        .setMinor(version.minor.toInt())
        .setRevision(version.revision.toInt())
        .build()

internal fun serializeDescriptor(descriptor: ProtocolDescriptor) =
    ProtocolDescriptorProto.newBuilder()
        .setName(descriptor.name)
        .setVersion(serializeVersion(descriptor.version))
        .build()

internal fun serializeMessage(message: ProtocolMessage) =
    ProtocolMessageProto.newBuilder()
        .setProtoDescriptor(serializeDescriptor(message.descriptor))
        .setMessage(ByteString.copyFrom(message.message))
        .build()

internal fun deserializeVersion(versionProto: ProtocolVersionProto) =
    ProtocolVersion(
        versionProto.major.toUShort(),
        versionProto.minor.toUShort(),
        versionProto.revision.toUShort()
    )

internal fun deserializeDescriptor(descriptorProto: ProtocolDescriptorProto) =
    ProtocolDescriptor(
        descriptorProto.name,
        version = deserializeVersion(descriptorProto.version)
    )

internal fun deserializeMessage(messageProto: ProtocolMessageProto) =
    ProtocolMessage(
        descriptor = deserializeDescriptor(messageProto.protoDescriptor),
        message = messageProto.message.toByteArray()
    )

fun protocolRouterOf(vararg protocols : Pair<ProtocolDescriptor, ExtensionNode>) : ProtocolRouterExtension {
    val router = ProtocolRouterExtensionImpl()
    router.protocols.putAll(protocols)
    return router
}

fun protocolRouterOf(vararg protocols: Map.Entry<ProtocolDescriptor, ExtensionNode>) : ProtocolRouterExtension {
    return protocolRouterOf(protocols.map { (k, v) -> k to v })
}

fun protocolRouterOf(protocols: List<Pair<ProtocolDescriptor, ExtensionNode>>) : ProtocolRouterExtension {
    return protocolRouterOf(*protocols.toTypedArray())
}